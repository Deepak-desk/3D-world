<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon City Flight</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Outfit', sans-serif;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
            z-index: 10;
        }

        h1 {
            font-weight: 800;
            font-style: italic;
            letter-spacing: -1px;
            border: 1px solid #00ffff;
            padding: 15px;
            backdrop-filter: blur(5px);
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        .metric {
            font-size: 0.9rem;
            color: #00ffff;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            width: 200px;
        }

        .metric span {
            color: #fff;
            font-weight: bold;
        }

        #webcam {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            opacity: 0.4;
            transform: scaleX(-1);
            border: 2px solid #00ffff;
            border-radius: 5px;
            z-index: 5;
        }

        .controls-hint {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.8rem;
            line-height: 1.6;
            text-align: right;
        }

        #speed-bar {
            width: 100%;
            height: 5px;
            background: #333;
            margin-top: 5px;
            position: relative;
        }

        #speed-fill {
            height: 100%;
            background: #ff0055;
            width: 0%;
            box-shadow: 0 0 10px #ff0055;
            transition: width 0.1s;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 5px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            50% {
                opacity: 0.5;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;800&display=swap" rel="stylesheet">
</head>

<body>
    <div id="ui-layer">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
            <div>
                <h1>CYBER DIVE</h1>
                <div style="color:#ff0055; font-size:1rem; letter-spacing:2px; font-weight:bold;">INFINITE CITY
                    SIMULATION</div>
            </div>
            <div class="hud-panel">
                <div class="metric">SPEED <span id="val-speed">0 KM/H</span></div>
                <div id="speed-bar">
                    <div id="speed-fill"></div>
                </div>
                <div class="metric" style="margin-top:10px;">ALTITUDE <span id="val-alt">0 M</span></div>
                <div class="metric">ZOOM <span id="val-zoom">1.0x</span></div>
            </div>
        </div>

        <div style="display:flex; justify-content:space-between; align-items:flex-end;">
            <div class="hud-panel" style="border-color: #ff0055; box-shadow: 0 0 15px rgba(255, 0, 85, 0.2);">
                <div style="color:#ff0055; font-weight:bold; margin-bottom:5px;">SYSTEM STATUS</div>
                <div id="status-text" style="color:#fff; font-size:0.8rem;">INITIALIZING...</div>
            </div>
            <div class="controls-hint">
                <strong>PILOT CONTROLS</strong><br>
                üñê RIGHT HAND: Steering (Pitch/Yaw)<br>
                ü§è PINCH: Turbo Boost<br>
                ‚ÜïÔ∏è HAND DISTANCE: Zoom In/Out
            </div>
        </div>
    </div>

    <div id="loading">Loading City...</div>
    <video id="webcam" autoplay playsinline muted></video>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { HandLandmarker, FilesetResolver } from "@mediapipe/tasks-vision";

        // --- CONFIG ---
        const BUILDING_COUNT = 4000;
        const CITY_SIZE = 400; // Width/Depth of city block
        const CHUNK_SIZE = 800; // Total render distance
        const FOG_COLOR = 0x050510;
        const NEON_BLUE = new THREE.Color(0x00ffff);
        const NEON_PINK = new THREE.Color(0xff0055);

        // --- STATE ---
        const state = {
            speed: 0,
            targetSpeed: 20,
            boost: false,
            hand: {
                active: false,
                x: 0, y: 0, z: 0, // Normalized -1 to 1
                pinch: false
            },
            cameraOffset: new THREE.Vector3(0, 0, 0)
        };

        // --- SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(FOG_COLOR);
        scene.fog = new THREE.FogExp2(FOG_COLOR, 0.008);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        // --- POST PROCESSING ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.5;
        bloomPass.radius = 0.5;
        composer.addPass(renderPass);
        composer.addPass(bloomPass);

        // --- CITY GENERATION (INSTANCED MESH) ---
        // Geometry: Simple Box
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);

        // Material: Custom Shader for "Windows"
        // We use the normal material but inject some emissive logic based on position
        const buildingMat = new THREE.MeshStandardMaterial({
            color: 0x101020,
            roughness: 0.2,
            metalness: 0.8,
        });

        // Add "Windows" via onBeforeCompile
        buildingMat.onBeforeCompile = (shader) => {
            shader.fragmentShader = shader.fragmentShader.replace(
                '#include <emissivemap_fragment>',
                `
                #include <emissivemap_fragment>
                // Procedural Windows
                float windows = 0.0;
                // Use world position for window pattern
                vec3 worldPos = vViewPosition; // Approx
                
                // Simple grid pattern on sides
                float wx = step(0.5, fract(vViewPosition.x * 5.0));
                float wy = step(0.5, fract(vViewPosition.y * 10.0));
                
                // Randomize windows
                float noise = fract(sin(dot(vViewPosition.xy ,vec2(12.9898,78.233))) * 43758.5453);
                
                if(noise > 0.5) {
                    totalEmissiveRadiance += vec3(0.0, 1.0, 1.0) * wx * wy * 2.0;
                }
                `
            );
        };

        const city = new THREE.InstancedMesh(boxGeo, buildingMat, BUILDING_COUNT);

        const dummy = new THREE.Object3D();
        const buildingData = []; // Store initial Z to loop

        for (let i = 0; i < BUILDING_COUNT; i++) {
            const w = 2 + Math.random() * 5;
            const h = 5 + Math.random() * 40; // Tall skyscrapers
            const d = 2 + Math.random() * 5;

            const x = (Math.random() - 0.5) * CITY_SIZE;
            const z = (Math.random() - 0.5) * CHUNK_SIZE * 2; // Spread deep

            dummy.position.set(x, h / 2, -z);
            dummy.scale.set(w, h, d);
            dummy.updateMatrix();

            city.setMatrixAt(i, dummy.matrix);

            // Store data for animation
            buildingData.push({
                x: x,
                y: h / 2,
                z: -z,
                scale: { x: w, y: h, z: d },
                speedOffset: Math.random() * 0.5
            });
        }
        city.instanceMatrix.needsUpdate = true;
        scene.add(city);

        // --- TRAFFIC (PARTICLES) ---
        const trafficCount = 2000;
        const trafficGeo = new THREE.BufferGeometry();
        const trafficPos = new Float32Array(trafficCount * 3);
        const trafficCol = new Float32Array(trafficCount * 3);
        const trafficSpeed = new Float32Array(trafficCount);

        for (let i = 0; i < trafficCount; i++) {
            trafficPos[i * 3] = (Math.random() - 0.5) * CITY_SIZE;
            trafficPos[i * 3 + 1] = Math.random() * 30; // Low altitude
            trafficPos[i * 3 + 2] = (Math.random() - 0.5) * CHUNK_SIZE;

            trafficSpeed[i] = 10 + Math.random() * 20;

            const col = Math.random() > 0.5 ? NEON_BLUE : NEON_PINK;
            trafficCol[i * 3] = col.r;
            trafficCol[i * 3 + 1] = col.g;
            trafficCol[i * 3 + 2] = col.b;
        }
        trafficGeo.setAttribute('position', new THREE.BufferAttribute(trafficPos, 3));
        trafficGeo.setAttribute('color', new THREE.BufferAttribute(trafficCol, 3));

        const trafficMat = new THREE.PointsMaterial({
            size: 0.5,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.8
        });
        const traffic = new THREE.Points(trafficGeo, trafficMat);
        scene.add(traffic);

        // --- LIGHTS ---
        const ambient = new THREE.AmbientLight(0x404040);
        scene.add(ambient);

        // Dynamic light attached to player
        const playerLight = new THREE.PointLight(0x00ffff, 2, 100);
        playerLight.position.set(0, 30, 10);
        scene.add(playerLight);

        // --- AI SETUP ---
        const video = document.getElementById("webcam");
        const statusText = document.getElementById("status-text");
        let handLandmarker = undefined;
        let lastVideoTime = -1;

        const setupAI = async () => {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            document.getElementById("loading").style.display = "none";

            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
        };
        setupAI();

        // --- LOOP ---
        const clock = new THREE.Clock();
        let totalDistance = 0;

        const animate = () => {
            const dt = clock.getDelta();

            // 1. Hand Tracking
            if (handLandmarker && video.videoWidth > 0 && video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, performance.now());

                if (results.landmarks.length > 0) {
                    const lm = results.landmarks[0];
                    const index = lm[8];
                    const thumb = lm[4];
                    const wrist = lm[0];

                    // Position (Steering)
                    // Center is 0.5, 0.5
                    state.hand.x = (0.5 - index.x) * 2; // -1 (left) to 1 (right)
                    state.hand.y = (0.5 - index.y) * 2; // -1 (down) to 1 (up)

                    // Z-Depth (Zoom)
                    // Estimate based on wrist size or bounding box?
                    // Simple: Wrist Y position relative to bottom? No.
                    // Let's use Palm Width (Index MCP to Pinky MCP)
                    const palmWidth = Math.hypot(lm[5].x - lm[17].x, lm[5].y - lm[17].y);
                    // Normal width ~0.15. Close ~0.3. Far ~0.05.
                    state.hand.z = (palmWidth - 0.15) * 10; // Approx range

                    // Pinch (Boost)
                    const pinch = Math.hypot(index.x - thumb.x, index.y - thumb.y);
                    state.hand.pinch = pinch < 0.05;
                    state.hand.active = true;

                    statusText.innerText = "SYSTEM ONLINE";
                    statusText.style.color = "#00ff00";
                } else {
                    state.hand.active = false;
                    // Auto pilot drift
                    state.hand.x *= 0.95;
                    state.hand.y *= 0.95;
                    state.hand.z *= 0.95;
                    state.hand.pinch = false;

                    statusText.innerText = "AUTOPILOT ENGAGED";
                    statusText.style.color = "#ff0055";
                }
            }

            // 2. Physics & Movement
            // Speed Control
            const baseSpeed = 40;
            const boostMult = state.hand.pinch ? 3.0 : 1.0;
            state.targetSpeed = baseSpeed * boostMult;
            state.speed += (state.targetSpeed - state.speed) * 0.1;

            const moveZ = state.speed * dt;
            totalDistance += moveZ;

            // Camera Movement (Steering)
            // We don't move camera Z, we move world Z (illusion)
            // But we DO move camera X/Y for steering
            state.cameraOffset.x += state.hand.x * dt * 20;
            state.cameraOffset.y += state.hand.y * dt * 20;

            // Clamp
            state.cameraOffset.x = Math.max(-50, Math.min(50, state.cameraOffset.x));
            state.cameraOffset.y = Math.max(10, Math.min(80, state.cameraOffset.y)); // Keep above ground

            // Smooth Camera Follow
            camera.position.x += (state.cameraOffset.x - camera.position.x) * 0.1;
            camera.position.y += (state.cameraOffset.y - camera.position.y) * 0.1;

            // Camera Rotation (Bank into turns)
            camera.rotation.z = -state.hand.x * 0.2; // Roll
            camera.rotation.x = -state.hand.y * 0.1; // Pitch

            // Zoom Effect (FOV)
            const targetFOV = 60 + (state.speed * 0.2) + (state.hand.z * 20);
            camera.fov += (targetFOV - camera.fov) * 0.1;
            camera.updateProjectionMatrix();

            // 3. Update World (Infinite Loop)
            // Buildings
            for (let i = 0; i < BUILDING_COUNT; i++) {
                let d = buildingData[i];

                // Move building towards camera (positive Z)
                d.z += moveZ;

                // Loop if behind camera
                if (d.z > 20) {
                    d.z -= CHUNK_SIZE * 2;
                    // Randomize X slightly on respawn for variety
                    d.x = (Math.random() - 0.5) * CITY_SIZE;
                }

                dummy.position.set(d.x, d.y, d.z);
                dummy.scale.set(d.scale.x, d.scale.y, d.scale.z);
                dummy.updateMatrix();
                city.setMatrixAt(i, dummy.matrix);
            }
            city.instanceMatrix.needsUpdate = true;

            // Traffic
            const tPos = trafficGeo.attributes.position.array;
            for (let i = 0; i < trafficCount; i++) {
                // Traffic moves faster than buildings
                tPos[i * 3 + 2] += moveZ + (trafficSpeed[i] * dt);

                if (tPos[i * 3 + 2] > 20) {
                    tPos[i * 3 + 2] -= CHUNK_SIZE;
                    tPos[i * 3] = (Math.random() - 0.5) * CITY_SIZE;
                }
            }
            trafficGeo.attributes.position.needsUpdate = true;

            // 4. HUD Updates
            document.getElementById('val-speed').innerText = Math.floor(state.speed * 10) + " KM/H";
            document.getElementById('val-alt').innerText = Math.floor(camera.position.y) + " M";
            document.getElementById('val-zoom').innerText = (camera.fov / 60).toFixed(1) + "x";

            const fillPct = (state.speed / 120) * 100;
            document.getElementById('speed-fill').style.width = Math.min(100, fillPct) + "%";

            composer.render();
            requestAnimationFrame(animate);
        };

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>